Rankings[4-6,]
# Lab step #20: everyone's IV-VI rank
Rankings[4:6,]
# lab step #21: II,V,VII ranks
Rankings[c(2,5,7),]
# lab step #22: Penny and stewie, episodes IV and VI
Rankings[c(4,6),c(2,4)]
# lab step #23: switch Lenny II and V
LV <- Rankings[5,3]
Rankings[5,3] <- Rankings[2,3]
Rankings[2,3] <- LV
# lab step #24: using row/column labels
Rankings["III","Penny"]
Rankingstable["III","Penny"]
LV <- Rankings["V","Lenny"]
Rankings["V","Lenny"] <- Rankings["II","Lenny"]
Rankings["II","Lenny"] <- LV
# lab step #26: re-do #23
LV <- Rankings["V","Lenny"]
LV <- Rankings["V","Lenny"]
Rankings["V","Lenny"] <- Rankings["II","Lenny"]
Rankings["II","Lenny"] <- LV
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/K)
return (Abundance[time])
}
}
# lab step 3a: paste lab 4, #7 script to lab 8
# equation: n[t] = n[t-1] + (r * n[t-1] * (K - n[t-1])/K)
#parameters
Abundance <- 2500     #initial population: n[1]
carryingCapacity <- 10000 #carrying capacity of population: K
growthRate <- 0.8         #intrinsic growth rate of population: r
#calculations
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/K)
print (Abundance[time])
}
#plot data
timeStep4 <- seq(1,12)
plot(timeStep4,Abundance)
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/K)
return (Abundance[time])
}
}
#calculations
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/K)
print (Abundance[time])
}
#calculations
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/K)
return (Abundance[time])
}
}
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/K)
}
return (Abundance[time])
}
return (Abundance)
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/K)
}
return (Abundance[time])
}
MyPopulationFunction(2000, 10000, 0.8)
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
}
return (Abundance[time])
}
MyPopulationFunction(2000, 10000, 0.8)
#calculations
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
MyPopulationFunction(2000, 10000, 0.8)
MyPopulationFunction(2500, 10000, 0.8)
Abundance[time]
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
return (Abundance[time])
}
MyPopulationFunction(2500, 10000, 0.8)
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
}
return (Abundance[time])
}
MyPopulationFunction(2500, 10000, 0.8)
# lab step 3b: make 3a into function
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
return (Abundance[time])
}
MyPopulationFunction(2500, 10000, 0.8)
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
timeStep4 <- seq(1,12)
plot(timeStep4,Abundance)
return (Abundance[time])
}
#test function
MyPopulationFunction(2500, 10000, 0.8)
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
(Abundance[time])
}
timeStep4 <- seq(1,12)
plot(timeStep4,Abundance)
return (Abundance[time])
}
#test function
MyPopulationFunction(2500, 10000, 0.8)
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
timeStep4 <- seq(1,12)
plot(timeStep4,Abundance)
return (Abundance[time])
}
#test function
MyPopulationFunction(2500, 10000, 0.8)
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(time) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
timeStep4 <- seq(1,12)
plot(timeStep4,Abundance)
return (Abundance[time])
}
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
timeStep4 <- seq(1,12)
plot(timeStep4,Abundance)
return (Abundance[time])
}
#test function
MyPopulationFunction(2500, 10000, 0.8)
# lab step 3d: write code that calls the function
? call
# lab step 3d: write code that calls the function
call ("MyPopulationFunction")
# lab step 3d: write code that calls the function
call ("MyPopulationFunction", Abundance, carryingCapacity, growthRate)
# lab step 3d: write code that calls the function
call ("MyPopulationFunction")
# lab step 3d: write code that calls the function
call ("MyPopulationFunction",2500, 10000, 0.8)
MyPopulationFunction(2, 6, .2)
call("MyPopulationFunction",2, 6, .2)
# lab step 3d: call the function
#test function
MyPopulationFunction(2300, 19000, 0.3)
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
timeStep <- seq(1,12)
plot(timeStep4,Abundance)
return (Abundance[time])
}
# lab step 3d: call the function
#test function
MyPopulationFunction(2300, 19000, 0.3)
# lab step 3e: write dataset from function to file with headers
print(Abundance)
# lab step 3e: write dataset from function to file with headers
as.matrix(Abundance)
colnames(Abundance) <- c("generations", "abundance")
print(Abundance)
# lab step 3e: write dataset from function to file with headers
AbundanceMatrix <- as.matrix(Abundance)
colnames(Abundance) <- c("generations", "abundance")
# lab step 3e: write dataset from function to file with headers
AbundanceMatrix <- as.data.frame(Abundance)
colnames(Abundance) <- c("generations", "abundance")
colnames(Abundance) <- ("generations", "abundance")
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
timeStep <- seq(1,12)
plot(timeStep4,Abundance)
return (Abundance[time])
}
str(Abundance)
# lab step 3e: write dataset from function to file with headers
AbundanceMatrix <- as.matrix(Abundance)
length(Abundance)
dim(Abundance)
dim(AbundanceMatrix)
# lab step 3e: write dataset from function to file with headers
AbundanceMatrix <- as.matrix(Abundance)
colnames(AbundanceMatrix) <- c("generations", "abundance")
rownames(AbundanceMatrix) <- c("generations", "abundance")
# lab step 3c: add to function to make it plot the data
MyPopulationFunction <- function(Abundance, carryingCapacity, growthRate) {
for (time in seq(2,12)) {
Abundance[time] <- Abundance[time-1] + (growthRate * Abundance[time-1] * (carryingCapacity - Abundance[time-1])/carryingCapacity)
print (Abundance[time])
}
timeStep <- seq(1,12)
plot(timeStep,Abundance)
return (Abundance[time])
}
AbundanceMatrix <- cbind(timestep, AbundanceMatrix)
AbundanceMatrix <- cbind(seq(1,12), AbundanceMatrix)
dim(AbundanceMatrix)
rownames(AbundanceMatrix) <- c("generations", "abundance")
rownames(AbundanceMatrix) <- c("generations", "abundance")
colnames(AbundanceMatrix) <- c("generations", "abundance")
dim(AbundanceMatrix)
print(AbundanceMatrix)
#export to file
write.csv(AbundanceMatrix, "logisticGrowthData")
#export to file
write.csv(AbundanceMatrix, "logisticGrowthData.csv")
# read data into script
# key-countries-pivoted dataset
KeyCountriesData <- read.csv("key-countries-pivoted.csv", stringsAsFactors = F)
#required libraries
library(ggplot2)
library(tidyr)
library(scales)
#convert key countries data frme to long form
longformcases <- with(KeyCountriesData,
data.frame(value = c(China, US, United_Kingdom, Italy, France, Germany, Spain, Iran),
variable = factor(rep(c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran"),
each = NROW(KeyCountriesData))),
Date = Date))
# format date as date for plotting
longformcases$Date <-as.Date(longformcases$Date)
# plot total cases
pdf("Total_Cases.pdf")
Total_Cases <- ggplot(longformcases, aes(Date, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Date", title= "COVID-19 Cases Over Time", y="Cases", colour= "Countries")+
theme (axis.text.x= element_text(angle=90))+
scale_x_date(date_breaks = "weeks", date_labels = "%m-%d")
print(Total_Cases)
dev.off()
# make data frame of national cases per capita
# data frame of national populations in millions
CountryPopulation <- data.frame(1392.73000,326.68750, 66.46034, 60.42176, 66.97711, 82.90578, 46.79654, 81.80027)
colnames(CountryPopulation) <- c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran")
rownames(CountryPopulation) <- ("population(millions)")
# normalize cases per country by population
KeyCountriesNoDate <- as.matrix(KeyCountriesData[,2:9]) #convert to matrix for sweep function
CountryPopulationMat <- as.matrix(CountryPopulation)
DataPerCapitaNoDate <- as.data.frame (sweep (KeyCountriesNoDate, 2, CountryPopulationMat, '/')) #use sweep to divide each value by national population
# attach date
Date <- KeyCountriesData$Date
KeyCountriesPerCapita <- cbind(Date, DataPerCapitaNoDate)
#convert per capita data to long form
longFormPerCap <- with(KeyCountriesPerCapita,
data.frame(value = c(China, US, United_Kingdom, Italy, France, Germany, Spain, Iran),
variable = factor(rep(c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran"),
each = NROW(KeyCountriesPerCapita))),
Date = Date))
# format date as date for plotting
longFormPerCap$Date <-as.Date(longFormPerCap$Date)
# plot cases per capita over time
pdf("Cases_Per_Cap.pdf")
Cases_Per_Cap <- ggplot(longFormPerCap, aes(Date, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Date", title= "COVID-19 Cases Per Capita", y="Cases Per Million People", colour= "Countries")+
theme (axis.text.x= element_text(angle=90))+
scale_x_date(date_breaks = "weeks", date_labels = "%m-%d")
print(Cases_Per_Cap)
dev.off()
# delete longFormPerCapita rows with zeros
LongFormNoZed <- subset(longFormPerCap, value!=0, select= c(value, variable))
LongFormNoZed <- LongFormNoZed[order(LongFormNoZed$variable),] #alphabetize by country name for applying count
lengthcount <- summarise(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
# pre-allocate count vector
DayNum <- rep(0, nrow(LongFormNoZed))
# write count sequences
for (ii in 1:nrow(lengthcount)) {
if(DayNum[ii]!=0) {
DayNum <- append(DayNum, (seq(1:lengthcount$`length(variable)`[ii])))
} else {
DayNum <- seq(1:lengthcount$`length(variable)`[ii])
}
}
# bind count to non-zero dataframe
LongFormNoZed <- cbind(DayNum, longFormNoZed)
# plot normalized per cap data
pdf("Norm_Cases_Per_Cap.pdf")
Norm_Cases_Per_Cap <- ggplot(LongFormNoZed, aes(DayNum, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Days Since First Case", title= "Normalized Cases Per Capita", y="Cases Per Million People", colour= "Countries")
print(Norm_Cases_Per_Cap)
dev.off()
getwd()
setwd("EBIO4420/CompBioLabsandHomework/Independent_Project/A")
setwd("EBIO4420/CompBioLabsandHomework/Independent_Project/Assignment_9/")
# read data into script
# key-countries-pivoted dataset
KeyCountriesData <- read.csv("key-countries-pivoted.csv", stringsAsFactors = F)
#required libraries
library(ggplot2)
library(tidyr)
library(scales)
#convert key countries data frme to long form
longformcases <- with(KeyCountriesData,
data.frame(value = c(China, US, United_Kingdom, Italy, France, Germany, Spain, Iran),
variable = factor(rep(c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran"),
each = NROW(KeyCountriesData))),
Date = Date))
# format date as date for plotting
longformcases$Date <-as.Date(longformcases$Date)
# plot total cases
pdf("Total_Cases.pdf")
Total_Cases <- ggplot(longformcases, aes(Date, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Date", title= "COVID-19 Cases Over Time", y="Cases", colour= "Countries")+
theme (axis.text.x= element_text(angle=90))+
scale_x_date(date_breaks = "weeks", date_labels = "%m-%d")
print(Total_Cases)
dev.off()
# make data frame of national cases per capita
# data frame of national populations in millions
CountryPopulation <- data.frame(1392.73000,326.68750, 66.46034, 60.42176, 66.97711, 82.90578, 46.79654, 81.80027)
colnames(CountryPopulation) <- c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran")
rownames(CountryPopulation) <- ("population(millions)")
# normalize cases per country by population
KeyCountriesNoDate <- as.matrix(KeyCountriesData[,2:9]) #convert to matrix for sweep function
CountryPopulationMat <- as.matrix(CountryPopulation)
DataPerCapitaNoDate <- as.data.frame (sweep (KeyCountriesNoDate, 2, CountryPopulationMat, '/')) #use sweep to divide each value by national population
# attach date
Date <- KeyCountriesData$Date
KeyCountriesPerCapita <- cbind(Date, DataPerCapitaNoDate)
#convert per capita data to long form
longFormPerCap <- with(KeyCountriesPerCapita,
data.frame(value = c(China, US, United_Kingdom, Italy, France, Germany, Spain, Iran),
variable = factor(rep(c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran"),
each = NROW(KeyCountriesPerCapita))),
Date = Date))
# format date as date for plotting
longFormPerCap$Date <-as.Date(longFormPerCap$Date)
# plot cases per capita over time
pdf("Cases_Per_Cap.pdf")
Cases_Per_Cap <- ggplot(longFormPerCap, aes(Date, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Date", title= "COVID-19 Cases Per Capita", y="Cases Per Million People", colour= "Countries")+
theme (axis.text.x= element_text(angle=90))+
scale_x_date(date_breaks = "weeks", date_labels = "%m-%d")
print(Cases_Per_Cap)
dev.off()
# delete longFormPerCapita rows with zeros
LongFormNoZed <- subset(longFormPerCap, value!=0, select= c(value, variable))
LongFormNoZed <- LongFormNoZed[order(LongFormNoZed$variable),] #alphabetize by country name for applying count
lengthcount <- summarise(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
# pre-allocate count vector
DayNum <- rep(0, nrow(LongFormNoZed))
# write count sequences
for (ii in 1:nrow(lengthcount)) {
if(DayNum[ii]!=0) {
DayNum <- append(DayNum, (seq(1:lengthcount$`length(variable)`[ii])))
} else {
DayNum <- seq(1:lengthcount$`length(variable)`[ii])
}
}
# bind count to non-zero dataframe
LongFormNoZed <- cbind(DayNum, longFormNoZed)
# plot normalized per cap data
pdf("Norm_Cases_Per_Cap.pdf")
Norm_Cases_Per_Cap <- ggplot(LongFormNoZed, aes(DayNum, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Days Since First Case", title= "Normalized Cases Per Capita", y="Cases Per Million People", colour= "Countries")
print(Norm_Cases_Per_Cap)
dev.off()
#required libraries
library(ggplot2)
library(tidyr)
library(scales)
#convert key countries data frme to long form
longformcases <- with(KeyCountriesData,
data.frame(value = c(China, US, United_Kingdom, Italy, France, Germany, Spain, Iran),
variable = factor(rep(c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran"),
each = NROW(KeyCountriesData))),
Date = Date))
# format date as date for plotting
longformcases$Date <-as.Date(longformcases$Date)
# plot total cases
pdf("Total_Cases.pdf")
Total_Cases <- ggplot(longformcases, aes(Date, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Date", title= "COVID-19 Cases Over Time", y="Cases", colour= "Countries")+
theme (axis.text.x= element_text(angle=90))+
scale_x_date(date_breaks = "weeks", date_labels = "%m-%d")
print(Total_Cases)
dev.off()
# make data frame of national cases per capita
# data frame of national populations in millions
CountryPopulation <- data.frame(1392.73000,326.68750, 66.46034, 60.42176, 66.97711, 82.90578, 46.79654, 81.80027)
colnames(CountryPopulation) <- c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran")
rownames(CountryPopulation) <- ("population(millions)")
# normalize cases per country by population
KeyCountriesNoDate <- as.matrix(KeyCountriesData[,2:9]) #convert to matrix for sweep function
CountryPopulationMat <- as.matrix(CountryPopulation)
DataPerCapitaNoDate <- as.data.frame (sweep (KeyCountriesNoDate, 2, CountryPopulationMat, '/')) #use sweep to divide each value by national population
# attach date
Date <- KeyCountriesData$Date
KeyCountriesPerCapita <- cbind(Date, DataPerCapitaNoDate)
#convert per capita data to long form
longFormPerCap <- with(KeyCountriesPerCapita,
data.frame(value = c(China, US, United_Kingdom, Italy, France, Germany, Spain, Iran),
variable = factor(rep(c("China", "US", "United_Kingdom", "Italy", "France", "Germany", "Spain", "Iran"),
each = NROW(KeyCountriesPerCapita))),
Date = Date))
# format date as date for plotting
longFormPerCap$Date <-as.Date(longFormPerCap$Date)
# plot cases per capita over time
pdf("Cases_Per_Cap.pdf")
Cases_Per_Cap <- ggplot(longFormPerCap, aes(Date, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Date", title= "COVID-19 Cases Per Capita", y="Cases Per Million People", colour= "Countries")+
theme (axis.text.x= element_text(angle=90))+
scale_x_date(date_breaks = "weeks", date_labels = "%m-%d")
print(Cases_Per_Cap)
dev.off()
# delete longFormPerCapita rows with zeros
LongFormNoZed <- subset(longFormPerCap, value!=0, select= c(value, variable))
LongFormNoZed <- LongFormNoZed[order(LongFormNoZed$variable),] #alphabetize by country name for applying count
lengthcount <- summarise(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
lengthcount <- summarize(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
library(dbplyr)
lengthcount <- summarise(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
lengthcount <- summarize(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
library(dplyr)
lengthcount <- summarize(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
lengthcount <- summarise(group_by(LongFormNoZed, variable),length(variable)) #count number of nonzero values for each country
# pre-allocate count vector
DayNum <- rep(0, nrow(LongFormNoZed))
# write count sequences
for (ii in 1:nrow(lengthcount)) {
if(DayNum[ii]!=0) {
DayNum <- append(DayNum, (seq(1:lengthcount$`length(variable)`[ii])))
} else {
DayNum <- seq(1:lengthcount$`length(variable)`[ii])
}
}
# bind count to non-zero dataframe
LongFormNoZed <- cbind(DayNum, longFormNoZed)
# bind count to non-zero dataframe
LongFormNoZed <- cbind(DayNum, LongFormNoZed)
# plot normalized per cap data
pdf("Norm_Cases_Per_Cap.pdf")
Norm_Cases_Per_Cap <- ggplot(LongFormNoZed, aes(DayNum, value, colour = variable, group=variable))+
geom_line()+
geom_point(size=0.75)+
labs(x= "Days Since First Case", title= "Normalized Cases Per Capita", y="Cases Per Million People", colour= "Countries")
print(Norm_Cases_Per_Cap)
dev.off()
